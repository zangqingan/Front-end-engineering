# Front-end-engineering
前端工程化学习

# 一、前端工程化概述
2023年了，前端开发工作，早已进入了前端工程化开发的时代，已经充满了各种现代化框架、预处理器、代码编译等各种工具、框架。
而前端工程化的本质就是利用工具链解决前端在团队开发过程中提升效率和质量的问题，进而能实现快速的交付。
最终落实到细节上，就是4个现代化:模块化、组件化、规范化、自动化。
在开发层面，前端工程化有以下这些好处：
  引入了模块化和包的概念，作用域隔离，解决了代码重名冲突的问题
  按需导出和导入机制，让编码过程更容易定位问题
  自动化的代码检测流程，有问题的代码在开发过程中就可以被发现
  编译打包机制可以让使用开发效率更高的编码方式，比如 Vue 组件、 CSS 的各种预处理器
  引入了代码兼容处理的方案（ e.g. Babel ），可以让自由使用更先进的 JavaScript 语句，而无需顾忌浏览器兼容性，因为最终会帮转换为浏览器兼容的实现版本
  引入了 Tree Shaking 机制，清理没有用到的代码，减少项目构建后的体积
除了对开发者有更好的开发体验和效率提升，对于团队协作，前端工程化也带来了更多的便利，例如下面这些场景：
  统一的项目结构，一般都是利用框架自带的脚手架工具创建的项目目录继续开发。
  统一的代码风格，利用插件实现代码保存时自动格式化，利于协作。
  可复用的模块和组件，通用的东西可以抽离封装，实现一次定义多处使用。
  代码健壮性有保障，编译器检测到问题就会抛出错误从而得以及时发现问题并修复，减少线上事故的发生。
  团队开发效率高 ，

# 二、vue.js与工程化
框架能够充分的利用前端工程化相关的领先技术，不仅在开发层面降低开发者的上手难度、提升项目开发效率，在构建出来的项目成果上也有着远比传统开发更优秀的用户体验。
而vue.js官方提供了脚手架vuecli和vite都是集成了工程化中非常常见的工具库。
实现方案是
node+vue2+webpack
node+vue3+vite

# 三、工程化的准备工作
1.命令行工具
命令行界面（ Command-line Interface ，缩写 CLI ），是一种通过命令行来实现人机交互的工具。个人使用的是git bash。也可使用其它的看个人爱好
https://github.com/microsoft/terminal
https://github.com/cmderdev/cmder
2.安装nodejs环境
3.初始化基础node项目
npm init -y 快速初始化为node项目，生成package.json文件用来管理项目安装的包，这个文件记录了这个项目的基础信息、依赖信息、开发过程的脚本行为、发布相关的信息等等。

# 四、工程化之模块化
在软件工程的设计原则里，有一个原则叫 “单一职责” ，目的是减少功能维护带来的风险，把代码块的职责单一化，让代码的可维护性更高。也就是说一个代码块负责一件事，每个单一职责的代码块就是一个模块（ Module ），把模块抽离出来放到一个文件里就叫做包（ Package ）。每个模块都有自己的作用域，功能与业务解耦，非常方便复用和移植。
模块（ Module ）和包（ Package ）是Node 开发最重要的组成部分，不管是全部自己实现一个项目，还是依赖各种第三方轮子来协助开发，项目的构成都离不开这两者。
在前端工程的发展过程中，不同时期诞生了很多不同的模块化机制，最为主流的有以下几种：
AMD 、CMD、CJS、ESM，其中AMD 、CMD都已经属于偏过去式的模块化方案已经基本不使用。
主要说说CJS、ESM。
ESM （ ES Module ） 是 JavaScript 在 ES6（ ECMAScript 2015 ）版本推出的模块化标准，旨在成为浏览器和服务端通用的模块解决方案。

CJS （ CommonJS ） 原本是服务端的模块化标准（设计之初也叫 ServerJS ），是为 JavaScript 设计的用于浏览器之外的一个模块化方案， Node 默认支持了该规范，在 Node 12 之前也只支持 CJS ，但从 Node 12 开始，已经同时支持 ES Module 的使用。
至此，不论是 Node 端还是浏览器端， 都可以用ESM了，ES Module 也就成了JavaScript统一的模块化标准了！

CJS 使用 module.exports 语法导出在模块文件中定义的任意合法的 JavaScript 类型，例如：字符串、布尔值、对象、数组、函数等等。
module.exports = 字符串名;
module.exports = 对象名;
module.exports = 数组名;
...
等等，也可以通过对象的形式一次性导出多个。
module.exports = {
  字符串,
  布尔值,
  对象,
  数组,
  函数,
  ....
}

使用 require 导入模块,单个导出时，若声明一个 m 变量接收，则接收的就是导出的变量可以直接使用。
若使用对象形式导出则接收的就是一个对象即整个对象导出的内容，此时需要使用 m.bar 的形式使用，也可以利用 ES6 的对象解构来直接拿到想要的变量。
当然如果需要也是可以在接收时重命名变量的。
// 这里进行了重命名foo
const { foo: foo2, bar } = require('./module.cjs')

ES Module 是新一代的模块化标准，它是在 ES6（ ECMAScript 2015 ）版本推出的，是原生 JavaScript 的一部分。需要通过 Babel 等插件工具进行代码的版本转换，不过肯定是以后的默认模块化标准了。
ESM 使用 export default （默认导出）和 export （命名导出）这两个语法导出模块，注意一个模块文件中只能有一个默认导出 export default。
和 CJS 一样， ESM 也可以导出任意合法的 JavaScript 类型，例如：字符串、布尔值、对象、数组、函数等等。
export default 字符串名;
export 字符串名;
export 对象名;
export 数组名;
....

使用 import ... from '模块所在路径' 导入模块导出的东西。
使用默认导出时不能使用对象解构的方法接收，接收变量名随意。
使用export命名导出的，导入时必须使用命名导入即 import { 接收变量名1, 接收变量名2, ..} from '../xx.js' 的格式
接收变量名和导出的变量名要严格的一一对应，当然你也可以对其重命名。与cjs规范重命名不同在于esm使用as关键字对需要重命名的变量重命名。
// 这里进行了重命名foo
const { foo as otherName, bar }  from '../xx.js' 


# 五、工程化之组件化
模块化是属于 JavaScript 的概念,而一个页面除了JavaScript外还包括HTML和css。根据不同的需求和功能对页面也进行模块化的划分我们称之为组件化。
在前端工程项目里，页面可以理解为一个积木作品，组件则是用来搭建这个作品的一块又一块积木。
通过把页面拆分成多个组件，可以降低维护成本，增加复用性。
每个组件也都有自己的 “作用域” ， JavaScript 部分利用 模块化 来实现作用域隔离， HTML 和 CSS 代码则借助 Style Scoped 来生成独有的 hash ，避免全局污染，这些方案组合起来，使得组件与组件之间的代码不会互相影响。

那么如何实现组件化？
在vue工程项目里是通过 Single-File Component （简称 SFC ， .vue 单文件组件）来实现组件化开发。



